/**/#include <LiquidCrystal_I2C.h>const int RXledPin = 2;volatile const int RXClockPin = 3;const int RXDataPin = 6;const int resetPin = 5;const byte crcPoly = 0x07;char message[16];int bitCounter = 0;volatile byte currByte = 0;volatile bool currBit = false;volatile bool clockIndicator = false;volatile bool endOfMessage = false;volatile bool recievedCrc = false;LiquidCrystal_I2C lcd(0x27, 16, 2);void setup() {  Serial.begin(9600);  pinMode(RXDataPin, INPUT);  pinMode(RXClockPin, INPUT);  pinMode(resetPin, INPUT);  pinMode(RXledPin, OUTPUT);  attachInterrupt(digitalPinToInterrupt(RXClockPin), onClockPulse, RISING);  strcpy(message, "");  lcd.init();  lcd.backlight();  lcdPrint("Ready", 0, 0);  delay(1000);  lcdPrint("     ", 0, 0);  Serial.println("Start recieving\n");};void loop() {  if (clockIndicator) {    if (!recievedCrc) {      updateLcd();    }    clockIndicator = false;  };  if (digitalRead(resetPin)) { //Preapeare for a new message    Serial.println("reset");    while (digitalRead(resetPin)) {};    resetVariables();    resetLcd();  }    if (recievedCrc) {    Serial.println()    lcdPrint("        ", 0, 1); //Clear display    if (!calcCrc(message, crcPoly)) {      lcdPrint("CRC: Good", 0, 1);    } else {      lcdPrint("CRC: Error", 0, 1);    };    recievedCrc = false;    clockIndicator = false;  }};void onClockPulse () {  currBit = digitalRead(RXDataPin);  if (currBit) { //Recieved a 1    currByte |= (0x80 >> bitCounter); //If a 1 is reacived set the current byte to 1 in the aproptiete place  };    bitCounter++;    if (bitCounter == 8) { //Full byte recieved    endOfMessage ? recievedCrc = true : recievedCrc = false;    currByte == 0 ? endOfMessage = true : endOfMessage = false;    strncat(message, &currByte, 1); //Add the recieved byte to the overall message    bitCounter = 0;    currByte = 0; //Set the byte back to 0  };    clockIndicator = true;  };void updateLcd() {  lcdPrint(message, 0, 0); //Print the message so far  for (int i = 0; i < 8; i++) { //Print the so far recieved bits    if (i < bitCounter) {      currByte & (0x80 >> i) ? lcdPrint("1", i, 1) : lcdPrint("0", i, 1);    } else {      lcdPrint(" ", i, 1);    };  };};void lcdPrint (char *printChar, int column, int row) { //Function to print on the LCD  lcd.setCursor(column, row);  lcd.print(printChar);};void resetLcd() { //Reset the LCD  lcdPrint("                ", 0, 0);  lcdPrint("                ", 0, 1);  lcd.setCursor(0, 0);}void resetVariables() {  strcpy(message, "");  bitCounter = 0;  currByte = 0;  currBit = false;  clockIndicator = false;  endOfMessage = false;  recievedCrc = false;}byte calcCrc(char *codeword, byte poly) {    char regByte = 0;  char bufferByte = 0;  bool regByteCheck = false;    regByte = codeword[0];    for (int byteIndex = 1; byteIndex <= strlen(message); byteIndex++) {        bufferByte = codeword[byteIndex];        for (int cycleIndex = 0; cycleIndex < 8; cycleIndex++) {      regByteCheck = regByte & 0x80;      regByte = regByte << 1;      regByte = regByte | ((bufferByte << cycleIndex) & 0x80) >> 7;      if (regByteCheck)  {        regByte = regByte ^ poly;      }    }  }     return regByte;}  void printByte (byte currentByte) {  Serial.println("");  for (int i = 0; i < 8; i++) {    Serial.println(bool(currentByte & (0x80 >> i)));  }  Serial.println("");}